---
layout: post
title: java中的GC
categories: [编程, java]
tags: [GC, jvm]
---


#### 1. 概念
`Garbage Collector`: 垃圾收集器，`jvm`中用于自动内存管理的具体实现

#### 2. 垃圾标记算法

##### 2.1 常用的垃圾标记算法

* `引用计数算法`: 记录对象被引用的次数，如果引用计数为`0`，则说明该对象可以被回收，缺点是无法回收`相互引用`的对象
* `根搜索算法`: 以`根对象`为起始点，搜索被其引用的对象，如果一个对象不可被`根对象`直接或间接引用，则说明该对象可以被回收，该算法解决了`相互引用`的问题，

> `java GC`采用`根搜索算法`

##### 2.2 根对象

`java`中的`根对象`包括：

* `Java 栈`中的对象
* `Native Method Stack`中的对象
* `常量池`中的对象
* `static`对象
* 的`Class`对象

#### 3. 垃圾清除算法

##### 3.1 标记-清除

`标记-清除(Mark-Sweep)`: 通过`垃圾标记算法`找出垃圾对象并直接清除其内存空间，缺点是效率低、容易产生`内存碎片`

##### 3.2 复制

`复制(Coping)`: `Java内存模型`将`堆`分为`新生代`和`老年代`，其中`新生代`又分为`Eden`、`From Survivor`和`To Survivor`，这里的`复制算法`指的便是`对象`在`Eden`、`Survivor`和`老年代`中复制的算法

复制动作发生在`Minor GC`时，复制规则：

* `Eden`中存活的对象会复制到`To Survivor`，其年龄为`1`
* `From Survivor`中的对象会复制到`To Survivor`，其年龄`+1`
* 当`From Survivor`中对象年龄达到`-XX:MaxTenuringThreshold`指定值时，直接复制到`老年代`
* 当`To Survivor`空间用完时，直接复制到`老年代`
* 复制完成后，`From Survivor`和`To Survivor`角色互换，以用于一下次`复制`

##### 3.3 标记-压缩

`标记-压缩(Mark-Compact)`: 标记出所有`垃圾对象`后，把所有`存活对象`移动到一片`连续的内存空间`，最后`清除垃圾对象`，常用于老年代的垃圾回收(`Full GC`或`Major GC`)

#### 4. 串行并行和Stop-the-World

* `串行回收`: 指的是同一时间只能运行一个垃圾回收线程(不管是否有多个`CPU`)
* `并行回收`: 指的是利用多`CPU`使用多线程来回收垃圾
* `Stop-the-World`: 不管是`串行`还是`并行`回收，其回收过程中都会暂停所有工作线程，

#### 5. 常用GC
![]({{site.url}}/public/2017-07-01-java-gc.png)

##### 5.1 Serial和Serial Old

* `Serial GC`: 用于`新生代`垃圾回收，其使用`复制算法` `串行`回收和`Stop-the-World`机制，由于复制算法的低效性，`Serial GC`适用于对可用性要求不高的场合，例如`client`模式

* `Serial Old`: 用于`老年代`垃圾回收，其使用`标记-压缩算法` `串行`回收和`Stop-the-World`机制

> `XX:+UseSerialGC`: 指定使用`Serial GC`和`Serial Old GC`

##### 5.2 ParNew

`ParNew GC`: 用于`新生代`垃圾回收，其使用`复制算法` `并行`回收和`Stop-the-World`机制，相比`Serial`的优势是加入了多线程的支持，可以充分发挥多`CPU`的优势

> `XX:+UseParNewGC`: 指定使用`ParNew GC`和`Serial Old GC`

##### 5.3 Parallel和Parallel Old

* `Parallel`: 用于`新生代`垃圾回收，其使用`复制算法` `并行`回收和`Stop-the-World`机制，在`ParNew`的基础上增加了更多精细的控制参数，例如指定垃圾回收时间占用`jvm`运行时间的比重、指定`Stop-the-World`的时间限制

* `Parallel Old`: 用于`老年代`垃圾回收，其使用`标记-压缩算法` `并行`回收和`Stop-the-World`机制

> `-XX:+UseParallelGC`: 指定使用`Parallel GC`和`Serial Old GC`   
> `-XX:+UseParallelOldGC`: 指定使用`Parallel GC`和`Parallel Old GC`   
> `-XX:GCTimeRatio`: 指定`GC`执行时间和`jvm`运行总时间的比率(计算公式为`1/1+N`)，默认`99`，即`1%`的时间用于垃圾回收   
> `-XX:MaxGCPauseMillis`: 设置`GC`时`Stop-the-World`的时间限制，`GC`会尽量(`但不保证一定`)在此时间内完成

##### 5.4 CMS

`CMS(Concurrent-Mark-Sweep)`: 用于`老年代`垃圾回收，其使用`标记-清除算法` `并行`回收和`Stop-the-World`机制，相比`Parallel Old`的优势是执行效率高，`Stop-the-World`时间短，其主要用于高并发、低延迟的场合

> `-XX:+UseConcMarkSweepGC`: 指定使用`ParNew GC`和`CMS GC`

##### 5. G1

`G1(Garbage-First)`: `G1`完全不同于以上几种`GC`，其把`堆内存`划分为`2048`个不同的`Region`块，每个块大小在`1M-32M`，所以`G1 GC`不区分`新生代`和`老年代`。由于`G1`会优先释放占用内存较大的块，并不会全堆扫描，所以其`Stop-the-world`的时间更短

> `-XX:+UseG1GC`: 指定使用`G1 GC`   
> `G1`在`jdk7u4`中发布，其目的是取代以上所有`GC`

#### 6. 参考

* [java内存模型]({{site.url}}/2017/06/27/java-memory/)